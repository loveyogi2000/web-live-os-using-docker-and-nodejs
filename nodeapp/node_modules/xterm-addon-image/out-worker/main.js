"use strict";
/**
 * Copyright (c) 2021 Joerg Breitbart.
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Decoder_1 = require("sixel/lib/Decoder");
const Colors_1 = require("sixel/lib/Colors");
// always free decoder ressources after decoding if it exceeds this limit
const MEM_PERMA_LIMIT = 4194304; // 1024 pixels * 1024 pixels * 4 channels = 4MB
// custom default palette: VT340 (lower 16 colors) + ANSI256 (up to 256) + zeroed (up to 4096)
const DEFAULT_PALETTE = Colors_1.PALETTE_ANSI_256;
DEFAULT_PALETTE.set(Colors_1.PALETTE_VT340_COLOR);
let imageBuffer;
let sizeExceeded = false;
let dec;
// setup options loaded from ACK
let pixelLimit = 0;
function messageHandler(event) {
    var _a;
    const data = event.data;
    switch (data.type) {
        case 3 /* MessageType.SIXEL_PUT */:
            if (!sizeExceeded) {
                dec.decode(new Uint8Array(data.payload.buffer, 0, data.payload.length));
                if (dec.height * dec.width > pixelLimit) {
                    sizeExceeded = true;
                    dec.release();
                    console.warn('image worker: pixelLimit exceeded, aborting');
                    postMessage({ type: 7 /* MessageType.SIZE_EXCEEDED */ });
                }
            }
            postMessage({ type: 6 /* MessageType.CHUNK_TRANSFER */, payload: data.payload.buffer }, [data.payload.buffer]);
            break;
        case 4 /* MessageType.SIXEL_END */:
            const success = data.payload;
            if (success) {
                if (!dec || !dec.width || !dec.height || sizeExceeded) {
                    postMessage({ type: 5 /* MessageType.SIXEL_IMAGE */, payload: null });
                }
                else {
                    const width = dec.width;
                    const height = dec.height;
                    const bytes = width * height * 4;
                    if (!imageBuffer || imageBuffer.byteLength < bytes) {
                        imageBuffer = new ArrayBuffer(bytes);
                    }
                    new Uint32Array(imageBuffer, 0, width * height).set(dec.data32);
                    postMessage({
                        type: 5 /* MessageType.SIXEL_IMAGE */,
                        payload: {
                            buffer: imageBuffer,
                            width,
                            height
                        }
                    }, [imageBuffer]);
                    imageBuffer = undefined;
                    if (dec.memoryUsage > MEM_PERMA_LIMIT) {
                        dec.release();
                    }
                }
            }
            sizeExceeded = false;
            break;
        case 6 /* MessageType.CHUNK_TRANSFER */:
            if (!imageBuffer) {
                imageBuffer = data.payload;
            }
            break;
        case 2 /* MessageType.SIXEL_INIT */:
            sizeExceeded = false;
            const { fillColor, limit } = data.payload;
            // palette null - always shared from previous decoding
            dec.init(fillColor, null, limit);
            break;
        case 1 /* MessageType.ACK */:
            pixelLimit = ((_a = data.options) === null || _a === void 0 ? void 0 : _a.pixelLimit) || 0;
            dec = new Decoder_1.Decoder({ memoryLimit: pixelLimit * 4, palette: DEFAULT_PALETTE });
            postMessage({ type: 1 /* MessageType.ACK */, payload: 1 /* AckPayload.ALIVE */, options: null });
            break;
    }
}
self.addEventListener('message', messageHandler, false);
//# sourceMappingURL=main.js.map