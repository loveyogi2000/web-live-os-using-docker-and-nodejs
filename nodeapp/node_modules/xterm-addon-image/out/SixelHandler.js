"use strict";
/**
 * Copyright (c) 2020 Joerg Breitbart.
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SixelHandler = void 0;
const Colors_1 = require("sixel/lib/Colors");
const ImageRenderer_1 = require("./ImageRenderer");
class SixelHandler {
    constructor(_opts, _storage, _coreTerminal, _workerManager) {
        this._opts = _opts;
        this._storage = _storage;
        this._coreTerminal = _coreTerminal;
        this._workerManager = _workerManager;
        this._size = 0;
        this._fillColor = 0;
        this._aborted = false;
    }
    reset() {
        // TODO: reset the sixel decoder to defaults
        // (only local version, as worker gets reloaded already)
        console.log('SixelHandler.reset...');
    }
    // called on new SIXEL DCS sequence
    hook(params) {
        // NOOP fall-through for all actions if worker is in non-working condition
        this._aborted = this._workerManager.failed;
        if (this._aborted) {
            return;
        }
        this._fillColor = params.params[1] === 1 ? 0 : extractActiveBg(this._coreTerminal._core._inputHandler._curAttrData, this._coreTerminal._core._colorManager.colors);
        this._size = 0;
        this._workerManager.sixelInit(this._fillColor, this._opts.sixelPaletteLimit);
    }
    // called for any SIXEL data chunk
    put(data, start, end) {
        if (this._aborted || this._workerManager.failed) {
            return;
        }
        if (this._workerManager.sizeExceeded) {
            this._workerManager.sixelEnd(false);
            this._aborted = true;
            return;
        }
        this._size += end - start;
        if (this._size > this._opts.sixelSizeLimit) {
            console.warn(`SIXEL: too much data, aborting`);
            this._workerManager.sixelEnd(false);
            this._aborted = true;
            return;
        }
        /**
         * copy data over to worker:
         * - narrow data from uint32 to uint8 (high codepoints are not valid for SIXELs)
         * - push multiple buffer chunks until all data got written
         *
         * We cannot limit data flow at the PUT stage as async pausing is
         * only implemented for UNHOOK in the parser. To avoid OOM from message flooding
         * we have `sixelSizeLimit` above in place.
         */
        let p = start;
        while (p < end) {
            const chunk = new Uint8Array(this._workerManager.getChunk());
            const length = Math.min(end - p, chunk.length);
            chunk.set(data.subarray(p, p += length));
            this._workerManager.sixelPut(chunk, length);
        }
    }
    /**
     * Called on finalizing the SIXEL DCS sequence.
     * Some notes on control flow and return values:
     * - worker is in non-working condition: NOOP with sync return
     * - `sixelSizeLimit` exceeded: NOOP with sync return
     * - `sixelEnd(false)`: NOOP with sync return
     * - `sixelEnd(true)`:
     *    async path waiting for `Promise<ISixelImage | null>`
     *    from worker depending on decoding success,
     *    a valid image definition will be added
     *    to the terminal before finally returning
     */
    unhook(success) {
        if (this._aborted || this._workerManager.failed) {
            return true;
        }
        const imgPromise = this._workerManager.sixelEnd(success);
        if (!imgPromise) {
            return true;
        }
        return imgPromise.then(data => {
            if (!data) {
                return true;
            }
            const canvas = ImageRenderer_1.ImageRenderer.createCanvas(this._coreTerminal._core._coreBrowserService.window, data.width, data.height);
            const ctx = canvas.getContext('2d');
            if (ctx) {
                const imageData = ImageRenderer_1.ImageRenderer.createImageData(ctx, data.width, data.height, data.buffer);
                ctx.putImageData(imageData, 0, 0); // still taking pretty long for big images
                this._storage.addImage(canvas);
            }
            this._workerManager.sixelSendBuffer(data.buffer);
            return true;
        });
    }
}
exports.SixelHandler = SixelHandler;
/**
 * Some helpers to extract current terminal colors.
 */
// get currently active background color from terminal
// also respect INVERSE setting
function extractActiveBg(attr, colors) {
    let bg = 0;
    if (attr.isInverse()) {
        if (attr.isFgDefault()) {
            bg = convertLe(colors.foreground.rgba);
        }
        else if (attr.isFgRGB()) {
            const t = attr.constructor.toColorRGB(attr.getFgColor());
            bg = (0, Colors_1.toRGBA8888)(...t);
        }
        else {
            bg = convertLe(colors.ansi[attr.getFgColor()].rgba);
        }
    }
    else {
        if (attr.isBgDefault()) {
            bg = convertLe(colors.background.rgba);
        }
        else if (attr.isBgRGB()) {
            const t = attr.constructor.toColorRGB(attr.getBgColor());
            bg = (0, Colors_1.toRGBA8888)(...t);
        }
        else {
            bg = convertLe(colors.ansi[attr.getBgColor()].rgba);
        }
    }
    return bg;
}
// rgba values on the color managers are always in BE, thus convert to LE
function convertLe(color) {
    if (Colors_1.BIG_ENDIAN)
        return color;
    return (color & 0xFF) << 24 | (color >>> 8 & 0xFF) << 16 | (color >>> 16 & 0xFF) << 8 | color >>> 24 & 0xFF;
}
//# sourceMappingURL=SixelHandler.js.map